{
    "zero-shot": "Write unit tests in Python for the following function.\n\ndef truncate_number(number: float) -> float:\n\n    \"\"\"\n\n    Given a positive floating point number, it can be decomposed into an integer part \n\n    (largest integer smaller than given number) and decimals (leftover part always smaller than 1). \n\n    Return the decimal part of the number.\n\n\n\n    >>> truncate_number(3.5)\n\n    0.5\n\n    \"\"\"\n\n    return number % 1.0",
    "few-shot": "Write unit tests in Python for the following function. Here are some examples:\nExample of basic unit test:\ndef add(a, b): return a + b\n\nTest:\nimport unittest\nclass TestAdd(unittest.TestCase):\n    def test_add(self):\n        self.assertEqual(add(1, 2), 3)\n\nNow for the function:\ndef truncate_number(number: float) -> float:\n\n    \"\"\"\n\n    Given a positive floating point number, it can be decomposed into an integer part \n\n    (largest integer smaller than given number) and decimals (leftover part always smaller than 1). \n\n    Return the decimal part of the number.\n\n\n\n    >>> truncate_number(3.5)\n\n    0.5\n\n    \"\"\"\n\n    return number % 1.0",
    "cot": "Write unit tests in Python for the following function. First, think step-by-step about the possible edge cases, scenarios, assertions and logic involved. Then write complete tests using unittest.\n\nFunction:\ndef truncate_number(number: float) -> float:\n\n    \"\"\"\n\n    Given a positive floating point number, it can be decomposed into an integer part \n\n    (largest integer smaller than given number) and decimals (leftover part always smaller than 1). \n\n    Return the decimal part of the number.\n\n\n\n    >>> truncate_number(3.5)\n\n    0.5\n\n    \"\"\"\n\n    return number % 1.0"
}